/*
Лекція "Модульне тестування (Unit Testing) PL/SQL СУБД Oracle".
Частина 1 - Створення тестових наборів 
за BlackBox-методом еквівалентого розбиття
 
*/

/*
Перевірка відповідності або тестування програмних модулів 
відбувається з використанням двох принципів:
−	принцип тестування чорної скриньки (BlackBox);
−	принцип тестування білої скриньки (WhiteBox).
BlackBox-принцип розглядає окремий програмний модуль як чорну скриньку, 
враховуючи лише зовнішній опис, специфікації її роботи.
WhiteBox-принцип вивчає вміст програмного модуля 
у вигляді алгоритмів роботи.
Метою тестування за BlackBox-принципом є перевірка умов, 
при яких поведінка програмного модуля не відповідає її специфікації. 
Для виявлення всіх помилок в програмі необхідно виконати вичерпне тестування, 
тобто тестування на всіх наборах вхідних даних. 
Для більшості програмних модулів це складно, 
тому застосовують «розумне тестування», 
при якому тестування програми обмежується 
невеликою підмножиною деяких наборів даних. 
При цьому необхідно вибирати найбільш підходящі підмножини, 
тобто підмножини з найвищою імовірністю виявлення помилок.

BlackBox-метод еквівалентного розбиття
базується на двох положеннях:
1)	вхідні набори даних необхідно розбити 
на кінцеве число класів еквівалентності, 
при цьому в одному класі еквівалентності містяться такі тести, 
що, якщо один тест з класу еквівалентності виявляє деяку помилку, 
то і будь-який інший тест з цього класу еквівалентності 
повинен виявляти цю саму помилку;
2)	кожен тест повинен включати, по можливості, 
якомога більше класів еквівалентності, 
щоб мінімізувати загальне число тестів.
Розробка тестових сценаріїв здійснюється в два етапи: 
−	виділення класів еквівалентності;
−	побудова тестових наборів, яку покривають класи еквівалентності.
Класи еквівалентності виділяються шляхом вибору 
кожної вхідної умови, наприклад, для параметрів процедури (функції), 
які беруться за допомогою детальної специфікації і розбиваються 
на дві і більше груп c використанням таблиці з наступними колонками:
−	опис вхідних умов;
−	правильні класи еквівалентності;
−	неправильні класи еквівалентності

Якщо існують декілька вхідних умов, тоді визначається :
- один правильний клас еквівалентності, 
який повинен задовольняти всім умовам;
- множина неправильних класів еквівалентності, 
для кожного з яких не повинна задовольнятися одна умова, 
тобто кількість неправильних класів еквівалентності 
співпадає з кількістю умов.

*/

SET LINESIZE 2000
SET PAGESIZE 100
SET SERVEROUTPUT ON

/* *********************************************************** 
Розглянемо приклад.
Припустимо, що є функціональна вимога
FR1 "Користувач реєструється в системі",
програмна реалізація якої  
повинна враховувати наступні умови значення імені користувача:
- умова 1) - рядок починається з латинської літери;
- умова 2) - довжина рядка не більше 15 символів;

BlackBox-метод еквівалентного розбиття пропонує наступні класи:
1) правильний клас еквівалетності: виконуються 1,2 умови
2) неправильний клас еквівалетності: не виконується 1-ша умова
3) неправильний клас еквівалетності: не виконується 2-га умова

*/

/* Модульне тестування (Unit-testing) 
регулярного виразу перевірки імені користувача 
*/

/* Test Case 1 (TC1) (правильний клас еквівалентності):
опис вхідних умов: username = 'user1'
Очікуваний результат: є відповідь
*/
SELECT * FROM dual 
WHERE 
    regexp_like('user1','^[a-zA-Z][a-zA-Z0-9]*') 
	AND length('user1') <= 15;
						

/* TC2 (неправильний клас еквівалентності):
опис вхідних умов: username = '1user1'
Очікуваний результат: no data found
*/
SELECT * FROM dual 
WHERE 
	regexp_like('1user1','^[a-zA-Z][a-zA-Z0-9]*') 
	AND length('1user1') <= 15;


/* TC3 (неправильний клас еквівалентності):
опис вхідних умов:  username = 'user1234567891011'
Очікуваний результат: no data found
*/
SELECT * FROM dual 
WHERE 
	regexp_like('user1234567891011','^[a-zA-Z][a-zA-Z0-9]*') 
	AND length('user1234567891011') <= 15;

