/*
Лекція "Основи керуванн€ SQL-запитами в СУБД Oracle".
Частина 3 - Життєвий цикл SQL-запиту. Етап 2-"Query Optimization"
*/

/*

Етап 2 - "Query Optimization" містить  чотири кроки:
1) трансформація SQL-запитів (Query Transformations):
	вирішує, чи потрібно переписати SQL-запит для створення 
	кращого фізичного плану виконання запиту, наприклад:
	- заміна назв выртуальних таблиць на їх SQL-запити;
	- перетворення піззапитів на звичайний JOIN;
	- заміна оператора OR на комбінацію із двох підзапитів, 
		об`єднаних оператором UNION ALL 
2) оцінка властивостей фізичного плану (Query Plan Estimator): 
	- кардинальність (cardinality) - згальна кількість рядків таблиць;
	- селективність (selectivity) - кількість рядків таблиць,
		які містить відповідь на SQL-запит;
	- вартість (cost) - відсоток використання процесору 
		та пристроїв вводу/виводу даних.
3) генерація фізичних планів; 
4) вибір кращого плану з найменшою вартістю
5) збереження результатів роботи етапів 1-2 в Shared Pool
для використання з майбутніми SQL-запитами

/*
Для виконання SQL-запиту СУБД необхідно пройти 
множину кроків алгоритму – план виконання (Execution Plan), 
який включає:
1) логічний план виконання – дерево реляційної алгебри, 
	у вузлах якого розташовано:
	1.1) вузли-листя дерева – вузли-таблиці БД;
	1.2) операції реляційної алгебри:
	- проекція – унарна операція виділення частини стовпців таблиці;
	- вибірка: – унарна операція виділення частини рядків 
		таблиці за заданою умовою;
	- з'єднання – бінарна операція поєднання двох таблиць 
		за заданою умовою;
	1.3) вузол-вершина дерева – тимчасова таблиця з відповіддю на запит
2) фізичний план виконання – розвиток дерева реляційної алгебри, 
	у вузлах якого розташовані алгоритми реалізації 
	операцій реляційної алгебри для реального доступу до 
	блоків даних БД, які містять опис:
	а) методів доступу до блоків даних (Access Methods) 
		або шлях доступу (Access Path);
	б) методів зв'язків між таблицями (Join Methods);
	в) типів зв'язків між таблицями (Join Types):
	- INNER JOINS;
	- OUTER JOINS (LEFT, RIGHT, FULL);
	- SEMI-JOINS - коли запит містить IN/EXISTS оператори;
	- ANTI-JOINS - коли запит містить NOT IN/EXISTS оператори;
	г) порядку зв'язків між таблицями (Join Orders)
	
Стратегії оптимізації поділяються на:
1) оптимізацію за правилами (rule-based optimizer - RBO), 
	використовує знання лише про структуру БД
2) оптимізацію за вартістю (cost-based optimizer - CBO), 
	використовує знання про вміст таблиць БД
Спочатку була лише RBO-оптимізація.
CBO функціонально включає RBO.
В сучасних версіях Oracle використовується лише CBO

Основні правила RBO-оптимізації:
1) якщо в дереві плану присутній вузол з операцією вибірки, 
	тоді він перемыщуэться ближче до листя дерева, 
	перед вузлами з операціями з'єднання (якщо вони є);
2) якщо в дереві плану є вузол-лист з таблицею БД 
	для якої у наступних вузлах використовується 
	відносно невелика частина стовпчиків з урахуванням їх розмірів, 
	тоді після цього вузла включається вузол операції проекції 
	із необхідними стовпчиками, щоб видалити непотрібні стовпчики

Основні правила CBO-оптимізації:
1)  RBO-оптимізація завжди використовує індекс, якщо він є;
2) однією з властивостей CBO-оптимізації є використання 
	селективності предикатів, що входять до запиту;
3) оцінка селективності використовується для оцінки необхідності 
	використання індексу та визначення порядку з'єднання таблиць;
4) для успішної роботи оптимізатора з використанням CBO-оптимізації 
	необхідно періодично виконувати збір статистики.
5) оцінку селективності можна використовувати, 
	якщо ймовірність появи всіх значень стовпчика однакова
6) коли ймовірності різних значень стовпчика таблиці - різні,
	тоді оцінка селективності не має сенсу і треба
	оцінювати гістограму - різновид стовпцевої діаграми,
	де кожний стовпчик діаграми містить ймовірність 
	появи значення відповідного стовпчика таблиц	
*/


/* Програмний пакет DBMS_STATS для збору статитиски. 
Приклади

EXEC DBMS_STATS.gather_database_stats;
EXEC DBMS_STATS.gather_database_stats(estimate_percent => 15);
EXEC DBMS_STATS.gather_database_stats(estimate_percent => 15, cascade => TRUE);

EXEC DBMS_STATS.gather_schema_stats('SCOTT');
EXEC DBMS_STATS.gather_schema_stats('SCOTT', estimate_percent => 15);
EXEC DBMS_STATS.gather_schema_stats('SCOTT', estimate_percent => 15, cascade => TRUE);

EXEC DBMS_STATS.gather_table_stats('SCOTT', 'EMPLOYEES');
EXEC DBMS_STATS.gather_table_stats('SCOTT', 'EMPLOYEES', estimate_percent => 15);
EXEC DBMS_STATS.gather_table_stats('SCOTT', 'EMPLOYEES', estimate_percent => 15, cascade => TRUE);

EXEC DBMS_STATS.gather_dictionary_stats;

EXEC DBMS_STATS.gather_index_stats('SCOTT', 'EMPLOYEES_PK');
EXEC DBMS_STATS.gather_index_stats('SCOTT', 'EMPLOYEES_PK', estimate_percent => 15);

EXEC DBMS_STATS.delete_database_stats;
EXEC DBMS_STATS.delete_schema_stats('SCOTT');
EXEC DBMS_STATS.delete_table_stats('SCOTT', 'EMP');
EXEC DBMS_STATS.delete_column_stats('SCOTT', 'EMP', 'EMPNO');
EXEC DBMS_STATS.delete_index_stats('SCOTT', 'EMP_PK');

EXEC DBMS_STATS.delete_dictionary_stats;
*/

