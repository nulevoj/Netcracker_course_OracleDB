/*
Лекція "Основи керування SQL-запитами в СУБД Oracle".
Частина 7 - Життєвий цикл SQL-запиту. Етап 2-"Query Optimization".
Керування етапом оптимізацією "Query Optimization"
*/

/*
Форма фізичного плану, створеного СУБД, залежить від мети оптимізації. 
Метою оптимізації може бути: 
- підвищення пропускної спроможності СУБД (THROUGHPUT);
- скорочення часу відповіді СУБД на запит (RESPONSE TIME).
Вибір мети оптимізації залежить від конкретного прикладу: 
а) для програм, які працюють у пакетному режимі 
	типу long read (складні звітні форми), 
	мета оптимізації – збільшення пропускної здатності, 
	коли для користувача важливим є час повного завершення, 
	а не час відповіді на окремі запити всередині пакету;
б) для інтерактивних програм (OLTP), 
	які містять короткі транзакції типу short read/write,
	мета оптимізації - скорочення часу відповіді, тому що користувач очікує:
	- швидко побачити перші рядки відповіді на його запит з читання;
	- швидко виконати запит на модифікацію;

Команда зміни режиму ALTER SESSION SET OPTIMIZER_MODE = режим; 
де режим:
- ALL_ROWS (за замовчуванням) – передавати клієнту відразу 
	всі рядки відповіді за метою THROUGHPUT;
- FIRST_ROWS [_1, _10, _100, _1000] – передавати клієнту рядки відповіді 
	порціями, наприклад, перші 1, 10, 100 або 1000 рядків, 
	дотримуючись мети RESPONSE TIME;
- RULE - вибір RBO-оптимізації (примусове встановлення, не рекомендується);
- CHOOSE - вибір CBO-оптимізації за наявності в БД статичної інформації, 
	але якщо інформація відсутня, буде обрано RBO-оптимізація;

ALL_ROWS-режим обирає Full-Table Scan перед Index Access.
FIRST_ROWS-режим обирає Index Access перед Full-Table Scan

*/

/******* Керування алгоритмами доступу на основі Optimizer Hints *********

CBO-оптимізація підвищує якість вибору алгоритмів доступу до даних, 
який залежить від знань СУБД про вміст таблиць БД.
Для невеликих БД такі знання накопичуються СУБД і ймовірність помилок 
	при виборі алгоритмів невелика.
Для великих БД процес накопичення знань може перевищити припустимий час.
Якщо адміністратор БД знає про особливості вмісту таблиць БД, 
	він може дати свої рекомендації СУБД, 
	не змушуючи СУБД витрачати ресурси сервера на збір статистики.
	
Oracle дозволяє програмісту керувати процесом оптимізації, 
	примусово вказуючи команди увімкнення 
	або відключення властивостей кроків фізичного плану - 
	Optimizer Hints (підказки)
Підказки задаються після слова SELECT всередині 
багаторядкового коментаря /* після додаткового символу +

*/

SELECT /*+ команда */ FROM …

/*
Підказки можна розділити на чотири групи:
- режим оптимізації;
- алгоритми операцій вибірки;
- алгоритми операцій з'єднання таблиць;
- порядок з'єднання таблиць.

1) Команди примусового включення режиму оптимізації: 
ALL_ROWS, FIRST_ROWS(n), RULE, CHOOSE – 
	локальне встановлення відповідного 
	режиму оптимізації тільки для заданого запиту;

2) Команди примусового включення алгоритмів операції вибірки:
INDEX(t index), 
INDEX_FFS(t index), 
INDEX_SS(t index) - вибірка з t по index: 
	full scan, fast full scan, split scan
FULL(t) - вибірка з t за алгоритмом table scan

3) Команди відключення алгоритмів операції вибірки: 
NO_INDEX, NO_INDEX_FFS, NO_INDEX_SS

4) Команди примусового включення алгоритмів операцій з'єднання таблиць:
USE_NL(t1 [,t2 …] ) – з'єднання Nested Loop USE_MERGE(t1 [,t2 …] ) – 
з'єднання Sort and Merge USE_HASH(t1 [,t2 …]) – Hash-з'єднання

5) Команди відключення алгоритмів з'єднання: 
	NO_USE_NL, NO_USE_MERGE, NO_USE_HASH

6) Команди примусового вказівки порядку з'єднання таблиць:
ORDERED – з'єднання таблиць в порядку їхньої присутності
	у FROM-фразі запиту;
LEADING( t1 [, t2 …] ) – з'єднання таблиць у зазначеному порядку
*/


SET LINESIZE 2000
SET PAGESIZE 100

-- SET AUTOTRACE OFF
SET AUTOTRACE TRACEONLY;

-- 
SELECT e.ename
	FROM emp e
	WHERE 
		e.empno = 7900;

/* Результат:  
--------------------------------------------------------------------------------------
| Id  | Operation                   | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |        |     1 |    20 |     0   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |     1 |    20 |     0   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | EMP_PK |     1 |       |     0   (0)| 00:00:01 |
--------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("E"."EMPNO"=7900)Statistics
----------------------------------------------------------
1 recursive calls - кількість рекурсивних викликів SQL-запитів
(відрізняється від 1, якщо використовуються внутрішні таблиці
           0 db block gets - кількість читань блоків даних з ОЗУ
         969 consistent gets - загальна кількість читань блоків даних
         327 physical reads - кількість читань блоків даних з диска
(при повторному запиті часто = 0)
        5174 загальна кількість оброблених рядків
*/

-- Підказка Full-сканування таблиці emp 
SELECT /*+ FULL(e) */ e.ename
	FROM emp e
	WHERE 
		e.empno = 7900;

/* Результат: 
--------------------------------------------------------------------------
| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |      |     1 |    20 |     2   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP  |     1 |    20 |     2   (0)| 00:00:01 |
--------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("E"."EMPNO"=7900)
Коментар: вартість більша в 2 рази в порівнянні з індексним скануванням
*/

-- Підказка ORDERED
SELECT /*+ ORDERED */ e.ename, d.dname, l.lname
	FROM emp e, dept d, loc l
	WHERE 
		l.locno = 10
		AND e.deptno = d.deptno
		AND d.locno = l.locno;

/* Результат: 
-----------------------------------------------------------------------------------------
| Id  | Operation                     | Name    | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |         |     5 |   385 |     3   (0)| 00:00:01 |
|   1 |  MERGE JOIN CARTESIAN         |         |     5 |   385 |     3   (0)| 00:00:01 |
|   2 |   NESTED LOOPS                |         |     5 |   275 |     3   (0)| 00:00:01 |
|   3 |    NESTED LOOPS               |         |    14 |   275 |     3   (0)| 00:00:01 |
|   4 |     TABLE ACCESS FULL         | EMP     |    14 |   280 |     3   (0)| 00:00:01 |
|*  5 |     INDEX UNIQUE SCAN         | DEPT_PK |     1 |       |     0   (0)| 00:00:01 |
|*  6 |    TABLE ACCESS BY INDEX ROWID| DEPT    |     1 |    35 |     0   (0)| 00:00:01 |
|   7 |   BUFFER SORT                 |         |     1 |    22 |     3   (0)| 00:00:01 |
|   8 |    TABLE ACCESS BY INDEX ROWID| LOC     |     1 |    22 |     0   (0)| 00:00:01 |
|*  9 |     INDEX UNIQUE SCAN         | LOC_PK  |     1 |       |     0   (0)| 00:00:01 |
-----------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   5 - access("E"."DEPTNO"="D"."DEPTNO")
   6 - filter("D"."LOCNO"=10)
   9 - access("L"."LOCNO"=10)
*/

-- Підказка LEADING
SELECT /*+ LEADING(loc, dept, emp) */ e.ename, d.dname, l.lname
	FROM emp e, dept d, loc l
	WHERE 
		l.locno = 10
		AND e.deptno = d.deptno
		AND d.locno = l.locno;

/* Результат: 
------------------------------------------------------------------------------------------
| Id  | Operation                      | Name    | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |         |     5 |   385 |     3   (0)| 00:00:01 |
|   1 |  NESTED LOOPS                  |         |     5 |   385 |     3   (0)| 00:00:01 |
|   2 |   NESTED LOOPS                 |         |    14 |   385 |     3   (0)| 00:00:01 |
|   3 |    NESTED LOOPS                |         |    14 |   588 |     3   (0)| 00:00:01 |
|   4 |     TABLE ACCESS BY INDEX ROWID| LOC     |     1 |    22 |     0   (0)| 00:00:01 |
|*  5 |      INDEX UNIQUE SCAN         | LOC_PK  |     1 |       |     0   (0)| 00:00:01 |
|   6 |     TABLE ACCESS FULL          | EMP     |    14 |   280 |     3   (0)| 00:00:01 |
|*  7 |    INDEX UNIQUE SCAN           | DEPT_PK |     1 |       |     0   (0)| 00:00:01 |
|*  8 |   TABLE ACCESS BY INDEX ROWID  | DEPT    |     1 |    35 |     0   (0)| 00:00:01 |
------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   5 - access("L"."LOCNO"=10)
   7 - access("E"."DEPTNO"="D"."DEPTNO")
   8 - filter("D"."LOCNO"=10)
*/
