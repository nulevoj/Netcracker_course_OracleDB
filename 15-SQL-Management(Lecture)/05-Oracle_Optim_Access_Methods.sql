/*
Лекція "Основи керування SQL-запитами в СУБД Oracle".
Частина 5 - Життєвий цикл SQL-запиту. Етап 2-"Query Optimization".
Аналіз методів доступу до блоків даних (Access Methods) 
або шляхів доступу (Access Path)
*/

SET LINESIZE 2000
SET PAGESIZE 60
SET SERVEROUTPUT ON

/*
У сучасних версіях СУБД Oracle за замовчуванням
використовується CBO-оптимізація 
Для зміни режиму використовується команда:
ALTER SESSION SET OPTIMIZER_MODE = 'режим';
режим = 'RULE' - стратегія оптимізації за правилами (RBO-режим)
*/

-- Примусове встановлення RBO-оптимізації
ALTER SESSION SET OPTIMIZER_MODE = 'RULE';
 
/* Формування плану виконання запиту.
Варіант 1 – використання команди EXPLAIN PLAN
та прямого доступу до таблиці PLAN_TABLE зі стовпчиками:
CARDINALITY – оцінна кількість рядків, що обробляються на заданому кроці
BYTES – оцінна кількість байт, що обробляються на заданому кроці
COST – оцінна вартість виконання операції, 
	яка залежить від CPU_COST та IO_COST
CPU_COST – значення, пропорційне кількості машинних циклів, 
	необхідні операції
IO_COST - значення, пропорційне кількості операцій читання блоків даних
*/

-- Необхідні права на доступ до налагоджувальної інформації
-- GRANT PLUSTRACE до системи;

-- очистити старий план під назвою 'plan1'
DELETE FROM plan_table 
	WHERE statement_id = 'plan1';
-- Сформувати новий план
EXPLAIN PLAN SET STATEMENT_ID = 'plan1' 
	FOR 
		SELECT e.* FROM emp e;	

-- Перегляд плану виконання запиту
col level FORMAT 999
col oper FORMAT A20
col options FORMAT A15
col object_name FORMAT A15
col access_predicates FORMAT A17
col filter_predicates FORMAT A17

SELECT LEVEL,LPAD('-',2*(LEVEL-1),'-')||operation oper, 
		options, object_name, 
		access_predicates, filter_predicates
	FROM plan_table
	START WITH id = 0 AND statement_id = 'plan1'
	CONNECT BY PRIOR id = parent_id AND statement_id = 'plan1';

/*
Варіант 2 - Використання команди EXPLAIN PLAN 
			та табличної функції DBMS_XPLAN.DISPLAY()
*/
EXPLAIN PLAN 
	FOR 
		SELECT e.* FROM emp e;
		
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY());

/* 
Варіант 3 - Використання команди SQLPlus SET AUTOTRACE 
Моживі налаштування прав доступу через користувача sys:
disconnect
connect sys/sys as sysdba 
@%oracle_home%\sqlplus\admin\plustrce.sql
grant plustrace to user; 
*/

/* 
Встановлення режимів отримання спрощеного плану виконання запиту
SET AUTOTRACE ON;
SET AUTOTRACE OFF;
SET AUTOTRACE ON EXPLAIN;
SET AUTOTRACE TRACEONLY;
*/

-- Встановлення режиму отримання фізичного плану та статистики
SET AUTOTRACE TRACEONLY;

/*
Алгоритм табличного сканування (Table Scan) 
забезпечує доступ до даних через послідовну вибірку 
всіх блоків даних таблиці:
1) Table Access Full – вибірка рядків на основі перегляду 
	всіх рядків таблиці (всіх блоків даних, в яких є таблиця)
2) Table Access By User RowID - вибір рядків з таблиці, 
	якщо в запиті вказано умову з ROWID,
	де ROWID – прихований стовпчик таблиці як фізична адреса рядка 
	таблиці у блоках БД: 
	- адреса файлу;
	- адреса сторінки (блоку даних) у файлі;
	- номер позиції на сторінці даних.

*/

/* Отримання фізичного плану
з алгоритмом доступу до таблиці типу "TABLE ACCESS FULL"
(найпростіший і найтрудомісткіший алгоритм
операції доступу до таблиці та операції вибірки)
*/
SELECT e.* 
	FROM emp e;

/* Результат через SQLPlus:
----------------------------------
| Id  | Operation         | Name |
----------------------------------
|   0 | SELECT STATEMENT  |      |
|   1 |  TABLE ACCESS FULL| EMP  |
----------------------------------
*/

/* Результат (детальний) :
--------------------------------------------------------------------------
| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |      |    14 |  1232 |     3   (0)| 00:00:01 |
|   1 |  TABLE ACCESS FULL| EMP  |    14 |  1232 |     3   (0)| 00:00:01 |
--------------------------------------------------------------------------
Note
-----
   - dynamic statistics used: dynamic sampling (level=2)
*/

/* Отримання фізичного плану
з алгоритмом доступу до таблиці типу "TABLE ACCESS BY USER ROWID"
(найменш трудомісткий алгоритм операції вибірки)
*/

-- Отримати значення колонки ROWID
SET AUTOTRACE OFF;
select ROWID,empno,ename 
	FROM emp;

-- Отримати фізичний план 
SET AUTOTRACE TRACEONLY;
SELECT empno,ename 
	FROM emp 
	WHERE ROWID = 'AAAit6AAMAAAB/lAAA';

/* Результат: 
-------------------------------------------
| Id  | Operation                  | Name |
-------------------------------------------
|   0 | SELECT STATEMENT           |      |
|   1 |  TABLE ACCESS BY USER ROWID| EMP  |
-------------------------------------------
*/

/*
Індекс - додаткова структура даних, 
з елементами як структури < ROWID, колонка >, 
де колонка – значення стовпчика таблиці, що у впорядкованому вигляді
Перевага індексу – прискорення операцій вибірки, 
	бо доступ до впорядкованих даних швидше за доступ 
	до випадково розташованих.
Недоліки використання індексу:
- надмірне місце на диску;
- додатковий час на оновлення при зміні значень стовпчиків таблиці,
	пов'язаних з індексом 
	(як у тригері під час оновлення матеріалізованих таблиць)

Основні типи індексів у СУБД Oracle:
- індекс за замовчуванням – збалансоване дерево впорядкованих ключів 
	(Balanced Tree, B-tree)
- UNIQUE - B-tree дерево, що гарантує унікальність значень, 
	створюване автоматично для обмежень типу PRIMARY KEY або UNIQUE
- функціональний – як параметр використовує будь-яку функцію 
	перетворення даних стовпчика;
- BITMAP – ефективний для стовпчиків з малою кількістю унікальних 
	значень ( до 10) та формує бітову матрицю:
	- стовпчики - унікальні значення,
	- рядки - всі рядки таблиці, 
	- комірки = 1 або 0.

Алгоритми індексного сканування: 
1) Index Scan - доступ до даних таблиці через послідовний доступ 
до елементів індексу окремих стовпчів;
2) Index Unique Scan - вибірка даних з індексу 
по колонці з обмеженнями PRIMARY KEY або UNIQUE;
3) Table Access By Index ROWID - вибірка рядків з таблиці, 
що використовує результати будь-якого алгоритму Index Scan 
через зв'язування рядка індексу з рядками таблиці за значенням ROWID
*/

/* Отримання фізичного плану
з алгоритмом доступу до таблиці типу "INDEX UNIQUE SCAN"
*/
SELECT empno
	FROM emp 
	WHERE empno = 7839;

/* Результат:  
------------------------------------
| Id  | Operation         | Name   |
------------------------------------
|   0 | SELECT STATEMENT  |        |
|*  1 |  INDEX UNIQUE SCAN| EMP_PK |
------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("EMPNO"=7839)

Коментар до плану:
1) для стовпчика empno автоматично створено індекс EMP_PK
	під час створення обмеження типу PRIMARY KEY;
2) операція проекції та операція вибірки використовують один стовпчик,
	за якою створено індекс, тому додаткові алгоритми не потрібні
*/

/* Отримання фізичного плану
з алгоритмами доступу до таблиці типу:
"INDEX UNIQUE SCAN"
"TABLE ACCESS BY INDEX ROWID"
*/
SELECT empno,ename
	FROM emp 
	WHERE empno = 7839;

/* Результат:  
----------------------------------------------
| Id  | Operation                   | Name   |
----------------------------------------------
|   0 | SELECT STATEMENT            |        |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |
|*  2 |   INDEX UNIQUE SCAN         | EMP_PK |
----------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("EMPNO"=7839)

Коментар до плану: операція проекції використовує додатковий стовпчик ename,
	для доступу до якого потрібний додатковий алгоритм
	TABLE ACCESS BY INDEX ROWID
*/


/************************* Створення індексу **************************
Синтаксис команди створення індексу: 
	CREATE [UNIQUE | BITMAP] INDEX <назва> ON <таблиця> 
	(стовпчик1, [ стовпчик 2 ...]) 
Індекси можуть бути:
- простий - на один стовпчик;
- складовий - на декілька стовпчиків.
Тимчасове увімкнення/вимкнення індексу 
	із збереженням процесу його оновлення:
ALTER INDEX <ім'я_індексу> ENABLE/DISABLE;
Тимчасове повне відключення індексу або включення індексу 
	із оновленням його структури:
ALTER INDEX <ім'я_індексу> UNUSABLE/REBUILD;

Додаткові алгоритми індексного сканування:
1) Index Range Scan – вибірка рядків на основі перегляду індексу, 
	якщо у предикаті запиту є операції:
		">, <, =" (при неунікальних значеннях стовпця), 
		like 'pattern%_' зі спец-символами після pattern, 
		а не перед ним
2) Index Full Scan - вибірка даних 
	із індексу тільки для стовпчика з NOT NULL значеннями
3) Index Fast Full Scan – вибірка даних з індексу, 
	коли у запиті присутні лише індексовані стовпчики індексу 
	(алгоритм швидше за Index Full Scan)
4) Index Skip Scan – вибірка даних зі складеного індексу, 
	якщо у предикаті запиту використовується стовпчик, 
	розташований в індексі не першим за порядком

*/


-- Створення B-tree-індексу для стовпчика ename
CREATE INDEX ename_index ON emp (ename);

/* Отримання фізичного плану з алгоритмом доступу до таблиці 
типу "INDEX RANGE SCAN"
*/
SELECT ename
	FROM emp 
	WHERE ename = 'KING';

/* Результат:  
----------------------------------------
| Id  | Operation        | Name        |
----------------------------------------
|   0 | SELECT STATEMENT |             |
|*  1 |  INDEX RANGE SCAN| ENAME_INDEX |
----------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("ENAME"='KING')
*/

