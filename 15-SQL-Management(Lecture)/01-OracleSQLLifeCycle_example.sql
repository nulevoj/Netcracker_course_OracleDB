/*
Лекція "Основи керування SQL-запитами в СУБД Oracle".
Частина 1 - Життєвий цикл SQL-запиту
*/

/********** СУБД як "чорна скринька" для програміста ***************

1) до появи стандарту SQL весь процес доступу до даних 
виконувався програмістом самостійно;
2) програміст повинен був знати все про алгоритми доступу;
3) стандарт SQL дозволив не замислюватись про алгоритми доступу:
	- програміст лише декларує питання, на яке СУБД відповідає;
	- програміст не описує алгоритми отримання відповіді
4) але тепер СУБД повинна знати алгоритми отримання відповіді
5) але тепер існують наступні неоднозначності:
	а) способів отримання відповіді на одне питання 
		в СУБД може бути багато;
	б) SQL надає багато способів опису того, 
	що потрібно отримати: 
		- різні способи зв'язків між таблицями; 
		- способи опису підзапитів, 
		- робота із таблицями як множинами.
6) відповідь на SQL-запит повинна бути:
	- правильною - відповідати на питання програміста;
	- швидкою - відповідати вимогам замовників
		програмного забезпечення, в якому є SQL-запит
7) для швидкості отримання відповіді СУБД намагається 
	подати SQL-запит у вигляді послідовності 
	операцій доступу до даних, мінімізуючи:
	а) розмір оперативної пам'яти, 
		необхідної для отримання відповіді на SQL-запит;  
	б) кількість операцій обміну даними із:
		- швидкою оперативною пам'яттю, але обмеженого розміру;
		- повільною довготривалою пам'яттю, 
			але необмеженного розміру;
*/

/********** СУБД як "біла скринька" для програміста ***************

1) але зусилля СУБД з обробки SQL-запиту від програміста 
	будуть успішними, якщо СУБД однозначно зрозуміє, 
	що мав на увазі програміст, описуючи SQL-запит;
2) без знання процесу виконання SQL-запиту 
	програміст може ввести СУБД у часткову оману:
	- СУБД надасть правильну відповідь;
	- але СУБД може піти довгим алгоритмічним шляхом, 
	збільшивши час на отримання відповіді 
	або збільшивши надмірну кількість ресурсів серверу
3) для невеликих програмних систем (з невеликою кількістю 
	користувачів або з БД невеликого розміру 
	у порівнянні з розміром оперативної пам'яті)
	така затримка часу буде непомітною;
4) для великих програмних систем затримка часу 
	на виконання SQL-запиту	вже може стати помітною 
	для її користувачів, 
	що може порушити нефункціональні вимоги 
	стосовно продуктивності роботи системи
5) звичаний програміст великої системи повинен:
	- розуміти основи роботи СУБД як "білої скриньки" - 
		знати основи внутрішніх процесів СУБД;
	- розуміти рекомендації, які надають спеціалісти 
		з продуктивності систем;
	- розуміти життєвий цикл SQL-запитів
*/

/**************** Життєвий цикл SQL-запитів *********************

Життєвий цикл SQL-запитів містить наступні три етапи.

Етап 1 - "Query Parsing" містить три кроки:
1) синтаксичний аналіз (Syntax Check) 
	для контролю правильності мови запиту
2) семантичний аналіз (Semantic Check) 
	для контролю правильності:
	- назв об'єктів БД:
		- таблиць, 
		- колонок, 
		- функцій;
	- типів даних:
		- вхідних параметрів у викликах функцій;
		- операторів в операціях порівняння 
			предикатів WHERE-фрази;
	- привілеїв доступу до об'єктів БД
3) аналіз повторюваності SQL-запитів (Shared Pool Check):
	1.1) хеш-значення рядка SQL-запиту порівнюється із
		хеш-значеннями, які було раніше збережено 
		для	попередніх SQL-запитів;
	а) хеш-значення формуються на основі перших 200 символів рядка,
		тому не рекомендуєься створювати великі SQL-запити,
		інакше це може призвести до класичної колізії хеш-значень,
		коли два різних великих SQL-запити вважаються однаковими;
	б) проблема колізій може вирішитися через:
		- заміну частини запиту на віртуальну таблицю; 
		- заміну складних запитів на PL/SQL-поцедури/функції;
		- впровадження Bind-змінних;	
	1.2) якщо хеш-значення не знайдено, 
		тоді Parsing = "Hard Parse" та перехід до етапу 2,
		інакше - Parsing = "Soft Parse" та перехід до 3-го етапу,
		тому що можна використати результати 2-го етапу для
		SQL-запиту, який вже виконувався

Етап 2 - "Query Optimization" містить п'ять кроки:
1) трансформація SQL-запитів (Query Transformations):
	вирішує, чи потрібно переписати SQL-запит для створення 
	кращого фізичного плану виконання запиту, наприклад:
	- заміна назв віртуальних таблиць на їх SQL-запити;
	- перетворення підзапитів на звичайний JOIN;
	- заміна оператора OR на комбінацію із двох підзапитів, 
		об`єднаних оператором UNION ALL 
2) оцінка властивостей фізичного плану (Query Plan Estimator): 
	- кардинальність (cardinality) - згальна кількість рядків таблиць;
	- селективність (selectivity) - кількість рядків таблиць,
		які містить відповідь на SQL-запит;
	- вартість (cost) - відсоток використання процесору 
		та пристроїв вводу/виводу даних.
3) генерація фізичних планів; 
4) вибір кращого плану з найменшою вартістю
5) збереження результатів роботи етапів 1-2 в Shared Pool
для використання з майбутніми SQL-запитами

Етап 3 - "Query Plan Execution" містить наступні кроки: 
1) виконання кроків обраного фізичного плану запиту,
	пд час якого оновлюється System Global Area (SGA) — 
	група структур спільної пам’яті всіх серверних 
	і фонових процесів одного екземпляра бази даних Oracle,
	яка серед різних структур містить дві важливі структури:
	а) структура "Database buffer cache", яка має особливості:
	- всі дані, які необхідно прочитати або змінити,
		отримуються лише з буферного кешу,
	- якщо данні в кешу відсутні, їх потрібно прочитати 
		з диска та зберегти у буферному кеші;
	- усі процеси користувача, підключені до БД, 
		мають спільний доступ до буферного кешу;
	- чим більше розмір буферного кешу, 
		тим більше даних можна завантажити в кеш, 
		зменшуючи кількість операцій з більш повільною
		довготривалою пам'яттю.
	б) стрруктура "Shared Pool", яка містить дані:
	- SQL-запити, які можна повторно використовувати;
	- словник бази даних, наприклад:
		- облікові записи користувачів; 
		- структури таблиць і індексів;
		- привілеї доступу користувачів до таблиць;
	- внутрішня форма коду PL/SQL-процедур/функцій
2) перетворення та передача відповіді на SQL-запит 
	у форматі розуміння програмою-клієнтом, 
	яка надіслала SQL-запит

*/

