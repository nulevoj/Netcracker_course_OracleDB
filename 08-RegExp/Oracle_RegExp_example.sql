/* 
Приклади до лекції з регулярних виразів.
Усі приклади використовують вхідні рядки як константи.
Тому для перевірки використовується таблиця dual, що зберігає фіктивне значення X.
OnLine-сервіс перевірки регулярних виразів - https://regexr.com/
*/

/*********************** Приклади 1 ***********************************/

/* 
Етап 1. SELECT-запити на просту вибірку на основі регулярних виразів
*/

-- 1.1 Перевірити присутність у рядку 11aaa символів 11. 
-- Оператор LIKE
SELECT * FROM dual 
WHERE 
    '11aaa' LIKE '%11%';

-- 1.2 Перевірити присутність у рядку 11aaa символів 11.
-- Функція regexp_like
SELECT * FROM dual 
WHERE 
     regexp_like('11aaa','11');

-- 2.1 Перевірити присутність на початку рядка 11aaa символів 11
-- Оператор LIKE
SELECT * 
FROM dual 
WHERE 
   '11aaa' LIKE '11%';

-- 2.2 Перевірити присутність на початку рядка 11aaa символів 11
-- Функція regexp_like. Прив'язка літералу-константи до початку рядка. 
SELECT * FROM dual 
WHERE 
    regexp_like('11aaa','^11');

-- 2.3 Перевірити присутність в кінці рядка aaa11 символів 11
-- Оператор LIKE
SELECT * FROM dual 
WHERE 
    'aaa11' LIKE '%11';

-- 2.4 Перевірити присутність в кінці рядка aaa11 символів 11
-- Функція regexp_like. Прив'язка літералу-константи до кінця рядка
SELECT * FROM dual WHERE regexp_like('aaa11','11$');

/*********************** Приклади 2 *************************************/
-- 3.1 Перевірити присутність у рядку одного із символів: a або b або c
-- Оператор LIKE
SELECT * FROM dual 
WHERE 
    'abc11' LIKE '%a%' 
    OR 'abc11' LIKE '%b%' 
	OR 'abc11' LIKE '%c%';

-- 3.2 Перевірити присутність у рядку одного із символів: a або b або c
-- Функції regexp_like. Альтернативні варіанти. 
SELECT * FROM dual 
WHERE 
    regexp_like('abc11', 'a|b|c');

-- 4 Перевірити присутність в кінці рядка одного із символів: a або b або c
-- Функції regexp_like. Об'єднання в групи альтернативних варіантів
-- з прив'язкою групи до кінця рядка: (a|b|c)$
SELECT * FROM dual 
WHERE 
    regexp_like('aaa11b', '(a|b|c)$');

-- 5 Перевірити присутність в кінці рядка одного із символів: a, b, c, d, e, f, g
-- Функції regexp_like. Створення символьного класу
-- з використанням діапазону значень: [a-g]
SELECT * FROM dual 
WHERE 
    regexp_like('aaa12', '[a-g]$');

-- 5 Перевірити відсутність в кінці рядка одного із символів: a, b, c, d, e, f, g
-- Функції regexp_like. Створення символьного класу
-- з використанням діапазону значень: [a-g]
-- Інвертований символьний клас
SELECT * FROM dual WHERE regexp_like('aaabc', '[^abcdefg]$');

-- 6 Перевірити присутність наприкінці рядка пар символів: ab,cd,ef
-- Функції regexp_like. Об'єднання в групи альтернативних варіантів
-- з прив'язкою групи до кінця рядка: (ab | cd | ef) $
SELECT * FROM dual WHERE regexp_like('aaacd', '(ab|cd|ef)$');

/*********************** Приклади 3 *********************************************/

-- 6 Перевірити присутність у рядку підрядків: C або C#
-- Символ повтору ?
SELECT * FROM dual WHERE regexp_like('C', 'C#?');

-- 7 Перевірити присутність у рядку підрядків: C, C0, C12, C123 і т.д.
-- Символ повтору *
SELECT * FROM dual WHERE regexp_like('C12', 'C[0-9]*');

-- 8 Перевірити присутність у рядку підрядків: F1, F3, F13, F135 і т.д.
-- Символ повтору +
SELECT * FROM dual WHERE regexp_like('F1', 'F[135]+');

-- 9 Перевірити присутність у рядку підрядків: G11, G12, G21, G22
-- Символ повтору {n}
SELECT * FROM dual WHERE regexp_like('G1', 'G[12]{2}');

-- 10 Перевірити присутність у рядку підрядків: K11, K12, K21, K22, K111
-- Символ повтору {n,}
SELECT * FROM dual WHERE regexp_like('K11', 'K[12]{2,}');

-- 11 Перевірити присутність у рядку підрядків: H55, H555, H5555
-- Символ повтору {n,m}
SELECT * FROM dual WHERE regexp_like('H123', 'H[5]{2,4}');

-- 12 Перевірити присутність у рядку підрядків: A[1], A[2], ... A[i], i <= 9
-- Екранування спеціальних (шаблонних) символів
SELECT * FROM dual WHERE regexp_like('A[1]', 'A\[[1-9]\]');

-- 13 Перевірити присутність у рядку підрядків: A[0], A[1], ... A[i], i <= 99
-- Спеціальний символ - будь-яка цифра
SELECT * FROM dual WHERE regexp_like('A[25]', 'A\d{1,2}');

-- 14 Перевірити присутність у рядку підрядків, що містять два будь-які символи
SELECT * FROM dual WHERE regexp_like('№№', '.{2}');


/*********************** Приклади 4 *********************************************/

-- 15 Перевірити присутність у рядку підрядків,
-- які містять будь-який символ крім цифр
SELECT * FROM dual WHERE regexp_like('#', '\D');

-- 16 Перевірити присутність у рядку пробілу
SELECT * FROM dual WHERE regexp_like('12 3', '\s');

-- 17 Перевірити відсутність у рядку пробілу
SELECT * FROM dual WHERE regexp_like(' ', '\S');

-- 18 Перевірити присутність у рядку двох символів у верхньому регістрі
SELECT * FROM dual WHERE regexp_like('AБ', '[[:upper:]]{2}');

-- 19 Перевірити присутність у рядку п'яти знаків пунктуації -,:;!
SELECT * FROM dual WHERE regexp_like('-,:;!', '[[:punct:]]{5}');

/* 
ЕТАП 2. SELECT-запити на складну вибірку даних на основі регулярних виразів
*/

-- 1 Знайти у рядку дві підряд повторювані однакові букви (не цифри):
SELECT * from dual WHERE regexp_like('СУУБД это','([[:alpha:]])\1');

-- 2 Знайти у рядку підряд повторювані однакові буквосполучення (не цифри):
SELECT * from dual WHERE regexp_like('СУСУБД это','([[:alpha:]]+)\1');

-- 3 Знайти у рядку підряд однакові цифри, що повторюються.:
SELECT * from dual WHERE regexp_like('Oracle 11XE','(\d)\1');

-- 4 Знайти у рядку два і більше повторюваних підряд слова
SELECT * from dual  
WHERE 
     regexp_like(
	     'Oracle это   это СУБД',
         '([[:alpha:]]+)([[:space:]]+)\1');

-- 5 Знайти у рядку три і більше повторюваних підряд слова
SELECT * from dual
WHERE 
    regexp_like(
	    'Oracle это это это СУБД',
        '([[:alpha:]]+)(\s+)\1\2\1');

-- 5.1 Знайти рядки з 3-ма або 4-ма цифрами,
-- після яких через пробіл йде 5 великих латинських букв
SELECT * FROM dual 
WHERE 
    regexp_like(
	    '123 ABCDE',
		'([0-9]{3,4}\s[A-Z]{5})');

-- 5.2 Використання спец.символів
SELECT * FROM dual 
WHERE 
	regexp_like(
	    '123 ABCDE',
		'(\d{3,4}\s[[:upper:]]{5})');

-- 6.1 Знайти рядки із дійсними числами, наприклад: .23, 0.23, 1.123, 33.1
SELECT * FROM dual 
WHERE 
    regexp_like(
        '11.123',
		'^([0-9]*\.[0-9]+)');

-- 6.1 Використання спец.символів
SELECT * FROM dual 
WHERE 
    regexp_like(
        '0.123',
		'(\d+\.\d+)');

/* 7. Знайти рядки з часом в американському форматі
"a.m" (Ante meri­diem - "до полудня") – час з 12 години ночі до 12 години дня
"p.m" (Post meri­diem - "після полудня") - час з 12 години дня до 12 години ночі
Наприклад, неприпустимий формат – 00:00, так як його замінює 12 am
*/
SELECT * FROM dual 
WHERE 
    regexp_like(
        '10:00 pm',
		'^(((1[012])|[1-9])(:[0-5][0-9])? (am|pm))$');

-- 8. Знайти рядки з часом у форматах типу "01:10" або "23:25"
SELECT * FROM dual 
WHERE 
    regexp_like(
	    '23:00',
		'^(([01]?[0-9]|2[0-3]):[0-5][0-9])$');

-- 9. Знайти рядки з телефонним номером у форматі (777)777-777-77
SELECT * FROM dual 
WHERE 
    regexp_like(
	    '(777)777-777-77',
		'\(\d{3}\)\d{3}\-\d{3}\-\d{2}');

/* 10.1 Знайти рядки з адресою E-mail у форматі login@dom2.dom1
Правила складання:
login має починатися з латинської літери;
dom2 – має починатися з латинської літери;
dom1 – латинські літери довжини від 2 до 4.
*/
SELECT * FROM dual 
WHERE 
    regexp_like(
	    'm@ukr.net',
		'^([a-z][a-z0-9._-]*@[a-z][a-z0-9._-]*\.[a-z]{2,4})$');

/* 10.2
Якщо адреса може бути серед інших слів
при створенні шаблону необхідно врахувати два випадки:
1) адреса знаходиться на початку рядка
2) адреса відокремлена пробілом або іншим символом пунктуації
*/
SELECT * FROM dual 
WHERE 
    regexp_like(
	    'sssss m@ukr.net',
	    '(\s+[a-z][a-z0-9._%-]+@[a-z0-9._%-]+\.[a-z]{2,4})|(^[a-z][a-z0-9._%-]+@[a-z0-9._%-]+\.[a-z]{2,4})');

-- 11 Додати колонку EMAIL з контролем корректної адреси
ALTER TABLE EMP ADD EMAIL VARCHAR(30);
ALTER TABLE EMP ADD CONSTRAINT EMAIL_IS_CORRECT
	CHECK (
	    regexp_like(
		    EMAIL,
			'^([a-z][a-z0-9._-]*@[a-z][a-z0-9._-]*\.[a-z]{2,4})$'));

-- Встановити коректну адресу
UPDATE EMP SET EMAIL = '1@ukr.net';

-- 12 Знайти рядки з IP-адресою, наприклад 192.168.0.1
SELECT * FROM dual 
WHERE 
    regexp_like(
	    '255.168.0.1',
        '^(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))$');

/* Перевірити умови створення безпечного пароля:
- Довжина рядка не менше 8 символів;
- не менше одного символу – цифра;
– не менше одного символу у нижньому регістрі;
– не менше одного символу у верхньому регістрі;
- не менше одного спеціального символу з множини {!@#$%^&*}

Кон'юнктивна нормальна форма (AND-оператори) з використанням випереджальної перевірки
(positive lookahead):
^(?=\S{8,})(?=.*[0-9])(?=.*[az])(?=.*[AZ])(?=.*[!@#$ %^&*])$

Випереджувальна (або ретроспективна) перевірка підтримується лише 
в Advanced RE (ARE),
тому може не підтримуватися деякими СУБД, наприклад, Oracle.
Рішення:
1) програмна реалізація через серію перевірок, об'єднаних AND-операцією
2) правило де Моргана для переходу від AND-операцій до OR-операцій
Правило де Моргана:
(у1 AND у2) = NOT (NOT (у1 AND у2)) = NOT (NOT(у1) OR NOT(у2))

Диз'юнктивна нормальна форма (OR-оператори):
^(\S{0,7}|[^0-9]*|[^a-z]*|[^A-Z]*|[^!@#$%^&*]*)$

*/
SELECT * FROM dual 
WHERE 
    NOT regexp_like(
	    'a12A345678#',
        '^(\S{0,7}|[^0-9]*|[^a-z]*|[^A-Z]*|[^!@#$%^&*]*)$');


/*********************** Приклади 5 ***************************************/

/* 
Етап 3. Запити на вилучення підрядків та перетворення даних з використанням регулярних виразів
*/

/* 
Підетап 3.1 - Вилучення з рядка підрядка, що задовольняє шаблону
*/

-- 1.1 Отримати з рядка 'E-mail my@rus.net' підрядок з адресою:
SELECT 
    regexp_substr(
        ' E-mail my@ukr.net ',
        '([a-z][a-z0-9._%-]+@[a-z0-9._%-]+\.[a-z]{2,4})') 
from dual;

-- 1.2 Отримати з рядка ' E-mail my@ukr.net E-mail my@ukr.net my2@ukr.net'
-- підрядок з 2-ю по порядку адресою:
SELECT regexp_substr(' E-mail my@ukr.net my2@ukr.net',
'([a-z][a-z0-9._%-]+@[a-z0-9._%-]+\.[a-z]{2,4})',
	1,2) from dual;

-- 2. Отримати підрядок, що містить час у форматах типу «9:15 am» або «12:25 pm»:
SELECT 
    regexp_substr(
	    'sss 9:15 am sssss ',
		'((1[012]|[1-9]):[0-5][0-9]? (am|pm))') 
FROM dual;

-- 3. Отримати підрядок, що містить телефонні номери у форматі (777) 777-777-77:
SELECT 
    regexp_substr(
	    'Мій телефон (777) 777-777-77. ',
	    '(\([0-9]{3,5}\)[ ]+[0-9]{3}\-[0-9]{3}\-[0-9]{2})')
FROM dual;

-- 4. Отримати з рядка 'СУУБД це' підряд букви, що повторюються:
SELECT 
    regexp_substr(
	    'СУУБД це','([[:alpha:]]+)\1') 
FROM dual;

-- 5. Отримати з рядка 'Oracle це це СУБД' два і більше повторюваних підряд слова:
SELECT 
    regexp_substr(
	    'Oracle це це СУБД',
		'(.+)([[:space:]]+)\1') 
FROM dual;

-- 6. Отримати з рядка 'Oracle це це це СУБД' три і більше повторюваних поспіль слова:
SELECT 
    regexp_substr(
	    'Oracle це це це СУБД',
	    '(.+)([[:space:]]+)\1\2\1') 
FROM dual;

/*********************** Приклади 6 **************************************/

/* 
Підетап 3.2 - Пошук та заміна в рядку підрядка, що задовольняє шаблон;
*/

-- 7. Замінити всі цифри на слово "цифра":
SELECT 
    regexp_replace(
	    '12+2=14','\d',
		'цифра') 
FROM dual;

-- 8. Замінити всі числа на слово "число":
SELECT 
    regexp_replace(
	    '12+2=14',
		'\d+','число') 
FROM dual;

-- 9. Замінити всі слова в лапках на слово "слово в лапках",
-- використовуючи "жадібний" квантор:
SELECT 
    regexp_replace(
	    ' "жадібний" квантор, "лінивий" квантор',
		'"[[:alpha:]]+"',
		'слово в лапках') 
FROM dual;

-- 10. Замінити всі слова в лапках на слово "слово в лапках",
-- використовуючи "лінивий" квантор:
SELECT 
    regexp_replace(
	    ' "жадібний" квантор, "лінивий" квантор','"\D+?"',
		'слово в лапках') 
FROM dual;

-- 11. Замінити другу цифру словом "цифра":
SELECT 
    regexp_replace(
	    '2+2=4','\d',
		'цифра',1,2) 
FROM dual;

-- 12. Замінити порядок слідування слів для отримання фрази
-- "сучасна СУБД - Oracle":
SELECT 
    regexp_replace(
        'Oracle - сучасна СУБД',
		'(.*)\s(.*)\s(.*)\s(.*)',
		'\3 \4 \2 \1') 
FROM dual;

/*********************** Приклади 7 *****************************************/

/* 
Підетап 3.3 - Пошук позиції підрядка в рядку, що задовольняє шаблон,
та підрахунок кількості рядків, що задовольняють шаблону (версія >= 12с)
*/

-- 1. Отримати позицію розташування підряд повторюваних букв:
SELECT 
    REGEXP_INSTR(
	    'СУУБД це',
		'([[:alpha:]]+)\1') 
FROM dual;

-- 2. Визначити кількість співробітників, які мають у прізвищі
-- дві підряд повторювані однакові букви
SELECT ENAME 
from EMP 
WHERE 
    regexp_like(
	    ENAME,
		'([[:alpha:]])\1');

/* 
Підетап 3.4 - Рекурсивна обробка даних із використанням регулярних виразів
*/

-- 13. Витягти з рядка підрядки, використовуючи роздільник ;
SELECT regexp_substr(str, '[^;]+', 1, level) str
FROM (
      SELECT ' 1; 2; test1.' str 
	  FROM dual ) t
CONNECT BY 
instr(str, ';', 1, level - 1) > 0;

-- 14. У рядку підрядки представляють структуру
-- field1=field2=field3@field3=field4@field5=field6=field7@...
-- Витягти з рядка підрядки та їх стовпці
COL str FORMAT A10
COL str1 FORMAT A10
COL str2 FORMAT A10
COL str3 FORMAT A10

select
  regexp_substr(str, '[^=]+', 1, 1) as str1,
  regexp_substr(str, '[^=]+', 1, 2) as str2,
  regexp_substr(str, '[^=]+', 1, 3) as str3
from (
		select regexp_substr(str, '[^@]+', 1, level) str
		from(
			select rtrim('field1=field2=field3@field3=field4@field5=field6=field7@','@') str
			from dual
		)
		CONNECT BY REGEXP_INSTR (str, '@', 1, level - 1) > 0
);

-- 15. Витягти з рядка дробові числа.
SELECT
regexp_substr
(str, '([[:digit:]]+[.]{1}[[:digit:]]+)+', 
1, level) str
FROM (
      SELECT 
' 5646.45, 45 sd eds,.sd 9 2 566.11 12.3' 
str FROM dual) t
CONNECT BY
 regexp_substr
 (str,'([[:digit:]][.]{1}[[:digit:]])+',1,
 level)  is not null;
